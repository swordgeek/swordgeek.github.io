<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C语言字符串赋值</title>
      <link href="2021/10/26/C%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%B5%8B%E5%80%BC/"/>
      <url>2021/10/26/C%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%B5%8B%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void set_string(char **dest, const char *src)&#123;    int len = strlen(src);    *dest = (char *)malloc(len+1);    memcpy_s(*dest, sizeof(*dest)/sizeof((*dest)[0]), src, sizeof(src)/sizeof(src[0]));    return;&#125;int main()&#123;    char *method = NULL;    set_string(&amp;method, &quot;POST&quot;);    puts(method);    free(method);    method = NULL;    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题</title>
      <link href="2021/03/31/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2021/03/31/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><blockquote><ul><li>OSI分层 （7层）<ul><li>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</li></ul></li><li>TCP/IP分层（4层）<ul><li>网络接口层、 网际层、运输层、 应用层。</li></ul></li><li>五层协议 （5层）<ul><li>物理层、数据链路层、网络层、运输层、 应用层。</li></ul></li><li>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器，网关）<ul><li>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）</li><li>网络层：<strong>IP</strong>、ICMP、<strong>ARP</strong>、<strong>RARP</strong>、OSPF、IPX、RIP、IGRP、 （路由器）</li><li>传输层：<strong>TCP</strong>、<strong>UDP</strong>、SPX</li><li>会话层：NFS、SQL、NETBIOS、RPC</li><li>表示层：JPEG、MPEG、ASII</li><li>应用层：<strong>FTP</strong>、<strong>DNS</strong>、Telnet、SMTP、<strong>HTTP</strong>、WWW、NFS</li></ul></li></ul></blockquote><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><blockquote><ol><li><p>端口</p><ul><li>HTTP的URL由“http://”起始且默认使用端口80</li><li>HTTPS的UR由“https://”起始且默认使用端口443。 </li></ul></li><li><p>安全性和资源消耗</p><ul><li>HTTP协议运行在TCP之上，所有传输的内容都是明文，<a href="">客户端</a>和服务器端都无法验证对方的身份。</li><li>HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。</li><li>所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。 </li></ul></li></ol><ul><li>对称加密<ul><li>密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密<a href="">算法</a>有DES、AES等；</li></ul></li><li>非对称加密<ul><li>密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密<a href="">算法</a>有RSA、DSA等。</li></ul></li></ul></blockquote><h3 id="HTTPS的加密过程"><a href="#HTTPS的加密过程" class="headerlink" title="HTTPS的加密过程"></a>HTTPS的加密过程</h3><blockquote><ul><li><p>证书验证，<a href="">客户端</a>发送一个证书请求个服务器端，服务器端返回证书，<a href="">客户端</a>对证书进行验证。 </p></li><li><p>交换密钥，使用非对称加密，<a href="">客户端</a>使用公钥进行加密，服务器端使用密钥解密。 </p></li><li><p>交换数据，使用对称加密的方式对数据进行加密，然后进行传输。</p></li></ul></blockquote><h3 id="长连接与短连接的区别"><a href="#长连接与短连接的区别" class="headerlink" title="长连接与短连接的区别"></a>长连接与短连接的区别</h3><blockquote><ul><li>长连接<ul><li>client方与server方先建立连接，连接建立后不断开，然后再进行报文发送和接收。这种方式下由于通讯连接一直存在。此种方式常用于P2P通信。</li></ul></li><li>短连接<ul><li>Client方与server每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此方式常用于一点对多点通讯。</li></ul></li></ul></blockquote><h3 id="HTTP2-0与HTTP1-x的区别"><a href="#HTTP2-0与HTTP1-x的区别" class="headerlink" title="HTTP2.0与HTTP1.x的区别"></a>HTTP2.0与HTTP1.x的区别</h3><blockquote><ul><li>新的二进制格式（Binary Format）<ul><li>HTTP1.x的解析是基于文本</li><li>HTTP2.0的协议解析决定采用二进制格式</li></ul></li><li>多路复用（MultiPlexing）：即连接共享，即每一个request都是是用作连接共享机制的</li><li>header压缩：HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li><li>服务端推送（server push）：同SPDY一样，HTTP2.0也具有server push功能。</li></ul></blockquote><h3 id="GET和POST方式的区别"><a href="#GET和POST方式的区别" class="headerlink" title="GET和POST方式的区别"></a>GET和POST方式的区别</h3><blockquote><ul><li><p>参数位置：GET方法参数位置包含在URL，POST方法参数包含在请求主体 </p></li><li><p>参数长度：GET方法的URL长度有限度，POST长度没有限制 </p></li><li><p>参数编码：GET方法参数编码是ASCII码，POST没有限制 </p></li><li><p>TCP数据包：GET方法产生一个TCP数据包，把首部和数据一起发送，POST方法产生两个TCP数据包，先发首部，服务器响应后再发数据</p></li></ul></blockquote><h3 id="Session和Cookie的区别"><a href="#Session和Cookie的区别" class="headerlink" title="Session和Cookie的区别"></a>Session和Cookie的区别</h3><blockquote><ul><li><p>储存位置：Cookie是<a href="">客户端</a>会话技术，数据保存在<a href="">客户端</a>，Session是服务器端会话技术，数据保存在服务器端。 </p></li><li><p>存储容量：Cookie一般&lt;=4KB，Session无限制。 </p></li><li><p>跨域支持：Cookie支持跨域，Session不支持。</p></li></ul></blockquote><h3 id="WebSocket通信流程"><a href="#WebSocket通信流程" class="headerlink" title="WebSocket通信流程"></a>WebSocket通信流程</h3><blockquote><ul><li><p>建立socket通信，包括客户端套接字（socket方法），服务器端绑定端口（bind方法），建立监听（listen方法），客户端创建连接（connect方法）。 </p></li><li><p>TCP三次握手建立连接 </p></li><li><p>客户端服务器端收发数据（send方法、recv方法），读写数据（read方法、write方法）。 </p></li><li><p>TCP四次挥手关闭连接 </p></li><li><p>关闭socket（close方法）</p></li></ul></blockquote><h3 id="DNS域名系统工作原理"><a href="#DNS域名系统工作原理" class="headerlink" title="DNS域名系统工作原理"></a>DNS域名系统工作原理</h3><blockquote><ol><li>查询 浏览器、操作系统 缓存。</li><li>请求 <strong>本地域名服务器</strong></li><li>本地域名服务器未命中缓存，其请求 <strong>根域名服务器</strong>。</li><li>根域名服务器返回所查询域的<strong>主域名服务器</strong>。（主域名、顶级域名，如com、cn）</li><li>本地域名服务器请求主域名服务器，获取该域名的 <strong>名称服务器</strong>（域名注册商的服务器）。</li><li>本地域名服务器向 名称服务器 请求 域名-IP 映射。</li><li>缓存解析结果</li></ol></blockquote><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><h3 id="TCP-UDP的区别"><a href="#TCP-UDP的区别" class="headerlink" title="TCP/UDP的区别"></a>TCP/UDP的区别</h3><blockquote><ul><li>连接<ul><li>UDP是无连接的，发送数据之前无需建立连接，发送数据结束后也无需释放连接。</li><li>TCP是面向连接的，在发送数据之前需要通过三次握手建立连接，发送数据结束后需要通过四次挥手释放连接。</li></ul></li><li>交付<ul><li>UDP用尽最大努力交付，即不保证可靠交付，主机不需要维持复杂的连接状态表。</li><li>TCP提供可靠交付，即通过TCP连接传送的数据，无差错、不丢失、不重复，并且按序到达。</li></ul></li><li>数据<ul><li>UDP是面向报文的，UDP对于应用层交下来的报文，添加首部后就向下交给IP层，既不合并，也不拆分，一次性交付一个完整的报文。</li><li>TCP是面向字节流的，TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</li></ul></li><li>通讯双方<ul><li>UDP支持一对一、一对多、多对一、多对多的交互通讯。</li><li>TCP连接是点对点（一对一），每一条TCP连接只能有两个端点。</li></ul></li><li>拥塞<ul><li>UDP没有拥塞控制，网络的拥塞不会使源主机的发送速率降低。</li><li>TCP通过慢启动、拥塞避免、快速重传、快速恢复等算法进行拥塞控制。</li></ul></li><li>首部<ul><li>UDP的首部开销小，只有8个字节。</li><li>TCP首部开销20字节。</li></ul></li></ul></blockquote><h3 id="TCP可靠连接的实现"><a href="#TCP可靠连接的实现" class="headerlink" title="TCP可靠连接的实现"></a>TCP可靠连接的实现</h3><blockquote><ul><li>TCP使用<strong>超时重传</strong>和<strong>冗余确认</strong>技术来处理超时、丢失等情况；<ul><li>发送方只设置一个定时器，只和发出去的最老的那个段相关联，一旦超时，发送方就只发送最老的那个报文段。</li><li><strong>快速重传：</strong>发送方收到某些段的连续3个冗余确认ACK，如果这时没有超时，就把这个段发出去。</li></ul></li><li>使用<strong>确认、序号</strong>等技术来保证按序到达；<ul><li><strong>累积确认：</strong>例如，发送方给接收方发送数据，接收方需要给ACK确认，如果ACK的number等于20，意味着接收方已经收到了19以及之前的所有的字节，并期望发送方从20（包括20）之后的字节开始发送。</li><li>如果接收方TCP的实体在接收窗口中接收到乱序到来的报文段，协议没有做出规范，可以缓存，也可以丢弃。</li></ul></li><li>使用<strong>校验和</strong>来检验是否报文段在传输过程中是否发生了错误；<ul><li>首先，把伪首部、TCP报头、TCP数据分为16位的字，如果总长度为奇数个字节，则在最后增添一个位都为0的字节。</li><li>把TCP报头中的校验和字段置为0（否则就陷入鸡生蛋还是蛋生鸡的问题）。</li><li>其次，用反码相加法累加所有的16位字（进位也要累加）。</li><li>最后，对计算结果取反，作为TCP的校验和。</li></ul></li></ul></blockquote><h3 id="TCP拥塞控制的方法"><a href="#TCP拥塞控制的方法" class="headerlink" title="TCP拥塞控制的方法"></a>TCP拥塞控制的方法</h3><blockquote><ul><li>慢启动<ul><li>当主机开始发送数据时，由于不清楚网络的负荷情况，如果立即把大量数据字节注入到网络，那么就有可能引起网络发生拥塞。所以应该先试探一下，由小到大逐渐增大拥塞窗口数值。<ul><li>连接建好的开始先初始化拥塞窗口$cwnd = 1$，表明可以传一个MSS大小的数据；</li><li>每当收到一个ACK，$cwnd++$; 呈线性上升；</li><li>每当过了一个往返时延RTT，$cwnd = cwnd \times 2$；呈指数上升</li><li>还有一个慢启动门限ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）</li></ul></li></ul></li><li>拥塞避免<ul><li>让拥塞窗口cwnd缓慢增大，即每经过一个往返时延RTT就把发送方的拥塞窗口cwnd加1.在拥塞避免阶段有“<strong>加法增大</strong>”的特点，拥塞窗口cwnd<strong>按线性规律缓慢增长</strong>。<ul><li>收到一个ACK时，cwnd = cwnd + 1/cwnd</li><li>当每过一个RTT时，cwnd = cwnd + 1</li></ul></li></ul></li><li>快速恢复<ul><li>对于引起TCP进入快速恢复状态的缺失报文段，对收到的每个冗余的ACK，cwnd的值增加一个MSS。最终，当对丢失报文段的一个ACK到达时，TCP在减半cwnd后进入拥塞避免状态。如果出现超时事件，将cwnd置为1，ssthresh设置为cwnd的一半，并进入慢启动状态。</li></ul></li></ul></blockquote><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="C:\Users\sword\AppData\Roaming\Typora\typora-user-images\image-20210331150233698.png" alt="image-20210331150233698"></p><blockquote><ul><li><p>第一次握手：<a href="">客户端</a>发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认； </p></li><li><p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态； </p></li><li><p>第三次握手：<a href="">客户端</a>收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，<a href="">客户端</a>和服务器进入ESTABLISHED状态，完成三次握手。 </p></li><li><p>握手过程中传送的包里不包含数据，三次握手完毕后，<a href="">客户端</a>与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p></li></ul></blockquote><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="https://qqadapt.qpic.cn/txdocpic/0/26079e0cc386c00fdb761115dffd4f85/0?w=975&h=629" alt="img"></p><blockquote><ul><li><p>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 </p></li><li><p>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。</p></li><li><p>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</p></li><li><p>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</p></li></ul></blockquote><h3 id="SSL握手"><a href="#SSL握手" class="headerlink" title="SSL握手"></a>SSL握手</h3><blockquote><ul><li>目的<ul><li> 客户端与服务器需要就一组用于保护数据的算法达成一致；</li><li>它们需要确立一组由那些算法所使用的加密密钥；</li><li>握手还可以选择对客户端进行认证。</li></ul></li><li>过程<ul><li>客户端将它所支持的算法列表和一个用作产生密钥的随机数发送给服务器；</li><li>服务器从算法列表中选择一种加密算法，并将它和一份包含服务器公用密钥的证书发送给客户端；该证书还包含了用于认证目的的服务器标识，服务器同时还提供了一个用作产生密钥的随机数；</li><li>客户端对服务器的证书进行验证(有关验证证书，可以参考<a href="http://www.cnblogs.com/happyhippy/archive/2006/12/23/601357.html">数字签名</a>)，并抽取服务器的公用密钥；然后，再产生一个称作pre_master_secret的随机密码串，并使用服务器的公用密钥对其进行加密(参考<a href="http://www.cnblogs.com/happyhippy/archive/2006/12/23/601357.html">非对称加/解密</a>)，并将加密后的信息发送给服务器；</li><li>客户端与服务器端根据pre_master_secret以及客户端与服务器的随机数值独立计算出加密和MAC密钥(参考<a href="http://www.cnblogs.com/happyhippy/archive/2006/12/23/601357.html">DH密钥交换算法</a>)。</li><li>客户端将所有握手消息的MAC值发送给服务器；</li><li>服务器将所有握手消息的MAC值发送给客户端。</li></ul></li></ul></blockquote><h3 id="为什么要有TIME-WAIT-2ms"><a href="#为什么要有TIME-WAIT-2ms" class="headerlink" title="为什么要有TIME_WAIT 2ms"></a>为什么要有TIME_WAIT 2ms</h3><blockquote><ul><li>为了保证A发送的最后一个报文段能够达到B。</li><li>防止已失效的连接请求报文段出现在本连接。</li></ul></blockquote><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="交换机和路由器的区别"><a href="#交换机和路由器的区别" class="headerlink" title="交换机和路由器的区别"></a>交换机和路由器的区别</h3><blockquote><ul><li><p>工作层次：交换机主要工作在数据链路层，路由器主要工作在网络层</p></li><li><p>转发依据：交换机转发依据的对象是MAC地址，路由器转发依据的对象是IP地址</p></li><li><p>功能：交换机功能较简单，只是将主机连接起来组件局域网，路由器可以将局域网连接起来，还能分割广播域，还能提供防火墙</p></li></ul></blockquote><h3 id="ARP协议的作用"><a href="#ARP协议的作用" class="headerlink" title="ARP协议的作用"></a>ARP协议的作用</h3><blockquote><p>将IP地址转换为物理地址</p></blockquote><h3 id="ARP协议的工作原理"><a href="#ARP协议的工作原理" class="headerlink" title="ARP协议的工作原理"></a>ARP协议的工作原理</h3><blockquote><ul><li><p>首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。</p></li><li><p>当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机IP地址，源主机MAC地址，目的主机的IP地址。</p></li><li><p>当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。</p></li><li><p>源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败</p></li></ul></blockquote><h4 id="MAC表"><a href="#MAC表" class="headerlink" title="MAC表"></a>MAC表</h4><p><img src="https://qqadapt.qpic.cn/txdocpic/0/efbfcd2a8fb730fa08fae311330eed26/0?w=564&h=407" alt="img"></p><h4 id="ARP表"><a href="#ARP表" class="headerlink" title="ARP表"></a>ARP表</h4><p><img src="C:\Users\sword\AppData\Roaming\Typora\typora-user-images\image-20210331155359112.png" alt="image-20210331155359112"></p><h4 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h4><ul><li>IPv4</li></ul><p><img src="C:\Users\sword\AppData\Roaming\Typora\typora-user-images\image-20210331155526243.png" alt="image-20210331155526243"></p><ul><li>IPv6</li></ul><p><img src="C:\Users\sword\AppData\Roaming\Typora\typora-user-images\image-20210331155609955.png" alt="image-20210331155609955"></p><h3 id="IPV6地址的基本类型"><a href="#IPV6地址的基本类型" class="headerlink" title="IPV6地址的基本类型"></a>IPV6地址的基本类型</h3><blockquote><ul><li><p>单播（unicast）：单播就是传统的点对点通信。</p></li><li><p>多播（multicast）：多播是一点对多点的通信，数据报发送到一组计算机中的每一个。IPV6没有广播的术语，而是将广播看作多播的一个特例。</p></li><li><p>任播（anycast）：这是IPV6增加的一种类型。任播的终点是一组计算机，但是数据包只交付给其中一个，通常是距离最近的一个。</p></li></ul></blockquote><h3 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h3><blockquote><ul><li><p>内部网关协议RIP（Routing Information <a href="">Proto</a>col）：RIP是一种分布式的基于距离向量的路由选择协议。 </p></li><li><p>内部网关协议OPSF（Open Shortest Path First）：OSPF是使用分布式的链路状态协议。 </p></li><li><p>外部网关协议BGP（Border Gateway <a href="">Proto</a>col）：边界网关协议。</p></li></ul></blockquote><h3 id="epoll的工作方式"><a href="#epoll的工作方式" class="headerlink" title="epoll的工作方式"></a><strong>epoll的工作方式</strong></h3><blockquote><ul><li>水平触发（LT）<ul><li>若就绪的事件一次没有处理完要做的事件，就会一直去处理。即就会将没有处理完的事件继续放回到就绪队列之中（即那个内核中的链表），一直进行处理。 </li></ul></li><li>边缘触发（ET） <ul><li>就绪的事件只能处理一次，若没有处理完会在下次的其它事件就绪时再进行处理。而若以后再也没有就绪的事件，那么剩余的那部分数据也会随之而丢失。</li></ul></li></ul></blockquote><h3 id="epoll-有select，poll的主要区别"><a href="#epoll-有select，poll的主要区别" class="headerlink" title="epoll 有select，poll的主要区别"></a>epoll 有select，poll的主要区别</h3><blockquote><ul><li>相比于select与poll， epoll最大的好处在于它不会随着监听fd数目的增长而降低效率；</li><li>内核中的select与poll的实现是采用轮询来处理的，轮询的fd数据越多，自然耗时也越多；</li><li>epoll的实现是基于回调的，如果fd有期望的事件发生就通过回调函数将其加入epoll的就绪对了当中，也就是说它只关心活跃的fd</li><li>内核/用户空间拷贝问题，当内核把fd消息通知给用户空间时，selec和poll采用了内存拷贝的方法，而epoll采用了共享内存的方式。</li></ul></blockquote><h2 id="浏览器输入网址之后发生了什么"><a href="#浏览器输入网址之后发生了什么" class="headerlink" title="浏览器输入网址之后发生了什么"></a>浏览器输入网址之后发生了什么</h2><blockquote><ol><li> DNS域名解析 </li><li> HTTP协议生成请求报文 </li><li> TCP协议将请求报文分割成报文段，进行可靠传输 </li><li> IP协议进行分组转发 </li><li> TCP协议重组请求报文 </li><li> HTTP协议对请求进行处理</li></ol><hr><ol><li><p>客户端浏览器通过DNS解析到<a href="http://www.baidu.com的ip地址220.181.27.48,通过这个ip地址找到客户端到服务器的路径.客户端浏览器发起一个http会话到220.161.27.48,然后通过tcp进行封装数据包,输入到网络层./">www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。</a></p></li><li><p>在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。</p></li><li><p>客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</p></li><li><p>客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。</p></li></ol></blockquote><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><blockquote><ul><li>对于单核单线程CPU而言，在某一时刻只能执行一条CPU指令。上下文切换(Context Switch)是一种<strong>将CPU资源从一个进程分配给另一个进程的机制</strong>。从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。<strong>在切换的过程中，操作系统需要先存储当前进程的状态(包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。</strong></li></ul></blockquote><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><blockquote><ul><li>进程是具有一定功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源调度和分配的一个独立单位。</li><li>线程是进程的实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。</li><li>一个进程可以有多个线程，多个线程也可以并发执行。</li><li>通俗点说，如果把浏览器看作是一个进程的话，那么浏览器下面的每个tab页可以看做是一个个的线程。</li></ul></blockquote><h2 id="守护、僵尸、孤儿进程的概念"><a href="#守护、僵尸、孤儿进程的概念" class="headerlink" title="守护、僵尸、孤儿进程的概念"></a>守护、僵尸、孤儿进程的概念</h2><blockquote><ul><li><strong>守护进程</strong>：运行在后台的一种特殊进程，<strong>独立于控制终端并周期性地执行某些任务</strong>。</li><li><strong>僵尸进程</strong>：一个进程 fork 子进程，子进程退出，而父进程没有wait/waitpid子进程，那么<strong>子进程的进程描述符仍保存在系统中</strong>，这样的进程称为僵尸进程。</li><li><strong>孤儿进程</strong>：一个<strong>父进程退出，而它的一个或多个子进程还在运行</strong>，这些子进程称为孤儿进程。（孤儿进程将由 init 进程收养并对它们完成状态收集工作）</li></ul></blockquote><h2 id="线程同步的方式有哪些"><a href="#线程同步的方式有哪些" class="headerlink" title="线程同步的方式有哪些"></a>线程同步的方式有哪些</h2><blockquote><ul><li>互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。</li><li>信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li><li>事件（信号）：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li><li>同步机制遵循的原则：<ul><li>空闲让进；</li><li>忙则等待（保证对临界区的互斥访问）；</li><li>有限等待（有限代表有限的时间，避免死等）；</li><li>让权等待，（当进程不能进入自己的临界区时，应该释放处理机，以免陷入忙等状态）</li></ul></li></ul></blockquote><h2 id="进程的通信方式有哪些"><a href="#进程的通信方式有哪些" class="headerlink" title="进程的通信方式有哪些"></a>进程的通信方式有哪些</h2><blockquote><ul><li>管道<ul><li>管道是一种半双工的通信方式，数据只能单项流动，并且只能在具有亲缘关系的进程间流动，进程的亲缘关系通常是父子进程。</li></ul></li><li>命名管道<ul><li>命名管道也是半双工的通信方式，它允许无亲缘关系的进程间进行通信。</li></ul></li><li>信号量<ul><li>信号量是一个计数器，用来控制多个进程对资源的访问，它通常作为一种锁机制。</li></ul></li><li>消息队列<ul><li>消息队列是消息的链表，存放在内核中并由消息队列标识符标识。</li></ul></li><li>信号<ul><li>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li></ul></li><li>共享内存<ul><li>共享内存就是映射一段能被其它进程访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问。</li></ul></li><li>套接字<ul><li>套接字也是一种进程间通信机制，与其它通信机制不同的是，它可用于不同机器间的进程通信。</li></ul></li></ul></blockquote><h2 id="什么是缓冲区溢出？有什么危害？其原因是什么？"><a href="#什么是缓冲区溢出？有什么危害？其原因是什么？" class="headerlink" title="什么是缓冲区溢出？有什么危害？其原因是什么？"></a>什么是缓冲区溢出？有什么危害？其原因是什么？</h2><blockquote><ul><li><p>缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</p></li><li><p>危害有以下两点：</p></li><li><p>程序崩溃，导致拒绝额服务</p></li><li><p>跳转并且执行一段恶意代码</p></li><li><p>造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。</p></li></ul></blockquote><h2 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h2><blockquote><p>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。</p></blockquote><h2 id="死锁产生的四个条件（有一个条件不成立，则不会产生死锁）"><a href="#死锁产生的四个条件（有一个条件不成立，则不会产生死锁）" class="headerlink" title="死锁产生的四个条件（有一个条件不成立，则不会产生死锁）"></a>死锁产生的四个条件（有一个条件不成立，则不会产生死锁）</h2><blockquote><ul><li>互斥条件：一个资源一次只能被一个进程使用</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</li><li>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺</li><li>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li></ul></blockquote><h2 id="死锁的处理基本策略和常用方法"><a href="#死锁的处理基本策略和常用方法" class="headerlink" title="死锁的处理基本策略和常用方法"></a>死锁的处理基本策略和常用方法</h2><blockquote><ul><li><p>预防死锁</p><ul><li><strong>资源一次性分配：</strong>（破坏请求和保持条件）</li><li><strong>可剥夺资源：</strong>即当某进程新的资源未满足时，释放已占有的资源（破坏不可剥夺条件）</li><li><strong>资源有序分配法：</strong>系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li></ul></li><li><p>避免死锁</p><ul><li>银行家算法<ul><li>进程申请资源的数量是有限的，每个进程在第一次申请资源时要声明完成该项目所需的最大资源量，在满足所有资源要求时，进程应及时归还。系统在进程申请的资源数量不超过自己拥有的最大值时，都应尽量满足客户的需要。</li><li>可利用资源向量 Available</li><li>最大需求矩阵Max</li><li>分配矩阵 Allocation</li><li>需求矩阵Need</li><li>Need[i,j] = Max[i,j] - allocation[i, j]</li></ul></li></ul></li><li><p>检测死锁</p><ul><li>首先为每个进程和每个资源指定一个唯一的号码；</li><li>然后建立资源分配表和进程等待表。</li></ul></li><li><p>解除死锁</p><ul><li><p><strong>剥夺资源：</strong>从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；</p><p><strong>撤消进程：</strong>可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。</p></li></ul></li></ul></blockquote><h2 id="进程有哪几种状态"><a href="#进程有哪几种状态" class="headerlink" title="进程有哪几种状态"></a>进程有哪几种状态</h2><blockquote><ul><li>就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源</li><li>运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数</li><li>阻塞状态： 进程等待某种条件，在条件满足之前无法执行</li></ul></blockquote><p><img src="https://pic2.zhimg.com/80/v2-f8e903fb92e0458073c84814d5940efd_720w.jpg" alt="img"></p><h2 id="用户态和核心态-内核态）之间的区别"><a href="#用户态和核心态-内核态）之间的区别" class="headerlink" title="用户态和核心态(内核态）之间的区别"></a>用户态和核心态(内核态）之间的区别</h2><blockquote><ul><li><p><strong>权限不一样。</strong></p></li><li><p><strong>用户态的进程能存取它们自己的指令和数据，但不能存取内核指令和数据（或其他进程的指令和数据）</strong>。</p></li><li><p><strong>核心态下的进程能够存取内核和用户地址某些机器指令是特权指令，在用户态下执行特权指令会引起错误。</strong>在系统中内核并不是作为一个与用户进程平行的估计的进程的集合。</p></li></ul></blockquote><h2 id="分页和分段的区别"><a href="#分页和分段的区别" class="headerlink" title="分页和分段的区别"></a>分页和分段的区别</h2><blockquote><ul><li>目的不同<ul><li>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。</li></ul></li><li>大小不同<ul><li>段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定</li></ul></li><li>地址空间不同<ul><li>段向用户提供二维地址空间；页向用户提供的是一维地址空间</li></ul></li><li>信息共享<ul><li>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。</li></ul></li><li>内存碎片<ul><li>页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；</li><li>而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。</li></ul></li></ul></blockquote><h2 id="操作系统中进程调度策略"><a href="#操作系统中进程调度策略" class="headerlink" title="操作系统中进程调度策略"></a>操作系统中进程调度策略</h2><blockquote><ul><li>FCFS(先来先服务)<ul><li>每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。</li></ul></li><li>最短作业优先调度算法<ul><li>最短的作业(CPU区间长度最小)最先调度</li><li>SJF可以保证最小的平均等待时间</li></ul></li><li>优先级<ul><li>系统将从后备队列中选择若干个优先权最高的作业装入内存</li><li>每个任务关联一个优先权，调度优先权最高的任务</li><li>注意：优先权太低的任务一直就绪，得不到运行，出现“饥饿”现象</li></ul></li><li>时间片轮转<ul><li>系统将所有的就绪进程<strong>按先来先服务的原则排成一个队列</strong>，每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms 到几百ms。<strong>当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾</strong>；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。</li><li>优点: 定时有响应，等待时间较短；缺点: 上下文切换次数较多</li><li>时间片太大，响应时间太长；吞吐量变小，周转时间变长；当时间片过长时，退化为FCFS</li></ul></li><li>多级队列调度算法<ul><li>将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。</li></ul></li><li>多级反馈<ul><li>应设置多个就绪队列，并为各个队列赋予不同的优先级。</li><li>当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第<em>n</em>队列后，在第<em>n</em> 队列便采取按时间片轮转的方式运行。</li><li>仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程.</li></ul></li></ul></blockquote><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><h3 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h3><blockquote><ul><li>最理想的状态下，我们给页面做个标记，挑选一个最远才会被再次用到的页面调出。当然，这样的算法不可能实现，因为不确定一个页面在何时会被用到。</li></ul></blockquote><h3 id="先进先出页面置换算法（FIFO）及其改进"><a href="#先进先出页面置换算法（FIFO）及其改进" class="headerlink" title="先进先出页面置换算法（FIFO）及其改进"></a>先进先出页面置换算法（FIFO）及其改进</h3><blockquote><ul><li><p>这种算法的思想和队列是一样的，该算法总是淘汰最先进入内存的页面，即<strong>选择在内存中驻留时间最久的页面予淘汰</strong>。</p></li><li><p>实现：把一个进程已调入内存的页面按先后次序链接成一个队列，并且设置一个指针总是指向最老的页面。</p></li><li><p>缺点：对于有些经常被访问的页面如含有全局变量、常用函数、例程等的页面，不能保证这些不被淘汰。</p></li></ul></blockquote><h3 id="最近最少使用页面置换算法LRU（Least-Recently-Used）"><a href="#最近最少使用页面置换算法LRU（Least-Recently-Used）" class="headerlink" title="最近最少使用页面置换算法LRU（Least Recently Used）"></a>最近最少使用页面置换算法LRU（Least Recently Used）</h3><blockquote><ul><li><p>根据页面调入内存后的使用情况做出决策。LRU置换算法是选择最近最久未使用的页面进行淘汰。</p></li><li><p>为每个在内存中的页面配置一个移位寄存器。定时信号将每隔一段时间将寄存器右移一位。最小数值的寄存器对应页面就是最久未使用页面。</p></li><li><p>利用一个特殊的栈保存当前使用的各个页面的页面号。每当进程访问某页面时，便将该页面的页面号从栈中移出，将它压入栈顶。因此，栈顶永远是最新被访问的页面号，栈底是最近最久未被访问的页面号。</p></li></ul></blockquote><h3 id="设计LRU缓存结构"><a href="#设计LRU缓存结构" class="headerlink" title="设计LRU缓存结构"></a>设计LRU缓存结构</h3><pre><code class="C++">class Solution &#123;public:    /**     * lru design     * @param operators int整型vector&lt;vector&lt;&gt;&gt; the ops     * @param k int整型 the k     * @return int整型vector     */       vector&lt;int&gt; LRU(vector&lt;vector&lt;int&gt; &gt;&amp; operators, int k) &#123;        vector&lt;int&gt; r;        vector&lt;int&gt; key;        vector&lt;int&gt;result;        for(int i = 0; i &lt; operators.size(); i++)&#123;            if(operators[i][0] == 1)&#123;                set(operators[i][1], operators[i][2], r, key, k);            &#125;            if(operators[i][0] == 2)&#123;                get(operators[i][1], r, key,result);            &#125;        &#125;        return result;    &#125;          void set(int a, int b, vector&lt;int&gt; &amp;r, vector&lt;int&gt; &amp;key, int k)&#123;        if(r.size() &lt; k)&#123;            key.push_back(a);            r.push_back(b);        &#125;        else&#123;            key.erase(key.begin());            r.erase(r.begin());            key.push_back(a);            r.push_back(b);        &#125;    &#125;          void get(int a, vector&lt;int&gt; &amp;r, vector&lt;int&gt; &amp;key ,vector&lt;int&gt; &amp;result)&#123;        int t = -1;        for(int i = 0; i &lt; key.size(); i++)&#123;            if(a == key[i])&#123;                t = i;                break;              &#125;        &#125;        if(t == -1)&#123;            result.push_back(-1);        &#125;        else&#123;            int t1, t2;            t1 = key[t];            t2 = r[t];            key.erase(key.begin() + t);            r.erase(r.begin() + t);            key.push_back(t1);            r.push_back(t2);            result.push_back(t2);        &#125;    &#125;&#125;;</code></pre><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><blockquote><ul><li>每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页(Page)，每个页都是一段连续的地址。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。这样，<strong>对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上，如图5所示。</strong></li><li>注意，请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。</li></ul></blockquote><h2 id="一个程序从开始运行到结束的完整过程（四个过程）"><a href="#一个程序从开始运行到结束的完整过程（四个过程）" class="headerlink" title="一个程序从开始运行到结束的完整过程（四个过程）"></a>一个程序从开始运行到结束的完整过程（四个过程）</h2><blockquote><ul><li>预处理：条件编译，头文件包含，宏替换的处理，生成.i文件。</li><li>编译：将预处理后的文件转换成汇编语言，生成.s文件</li><li>汇编：汇编变为目标代码(机器代码)生成.o的文件</li><li>链接：连接目标代码,生成可执行程序</li></ul></blockquote><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="C-多态"><a href="#C-多态" class="headerlink" title="C++多态"></a>C++多态</h2><blockquote><p>多态是在不同继承关系的类对象，有一个函数且名字、参数、返回值均相同，然后我们通过调用函数来实现不同类对象完成不同的事件</p></blockquote><blockquote><ul><li>构成多态的两个条件<ul><li>调用函数的对象必须是指针或者引用。</li><li>被调用的函数必须是虚函数，且完成了虚函数的重写。</li></ul></li></ul></blockquote><blockquote><p>派生类对象的地址可以赋值给基类指针。对于通过基类指针调用基类和派生类中都有的同名、同参数表的虚函数的语句，编译时并不确定要执行的是基类还是派生类的虚函数；而当程序运行到该语句时，如果基类指针指向的是一个基类对象，则基类的虚函数被调用，如果基类指针指向的是一个派生类对象，则派生类的虚函数被调用。</p></blockquote><blockquote><p>所谓“虚函数”，就是在声明时前面加了 virtual 关键字的成员函数。virtual 关键字只在类定义中的成员函数声明处使用，不能在类外部写成员函数体时使用。静态成员函数不能是虚函数。</p></blockquote><h2 id="C-的class和C的struct的区别"><a href="#C-的class和C的struct的区别" class="headerlink" title="C++的class和C的struct的区别"></a>C++的class和C的struct的区别</h2><blockquote><ul><li>C语言中结构体不允许定义函数成员，且没有访问控制属性的概念。</li><li>C++为C语言中的结构体引入了成员函数、访问控制权限、继承、包含多态等面向对象特性。</li><li>C语言中，空结构体的大小为0，而C++中空结构体（属于空类）的大小为1。</li><li>同时，C++的struct和class仅有访问权限的区别<ul><li>class默认私有类型（private）</li><li>struct默认公有类型（public）</li></ul></li></ul></blockquote><h2 id="C-空类的大小为1"><a href="#C-空类的大小为1" class="headerlink" title="C++空类的大小为1"></a>C++空类的大小为1</h2><blockquote><ul><li>空类也可以实例化，类实例化出的每个对象都需要有不同的内存地址，为使每个对象在内存中的地址不同，所以在类中会加入一个隐含的字节。</li></ul></blockquote><h2 id="C-动态分配内存"><a href="#C-动态分配内存" class="headerlink" title="C++动态分配内存"></a>C++动态分配内存</h2><blockquote><ul><li>C语言中，使用malloc/calloc/relloc来进行内存的动态开辟，用free来完成内存的释放；</li><li>C++中是通过new和delete这两个操作符来实现的。</li></ul></blockquote><h2 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h2><blockquote><ul><li>属性<ul><li>new/delete是C++关键字，需要编译器支持</li><li>malloc/free是库函数，需要头文件支持</li></ul></li><li>参数<ul><li>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。</li><li>malloc则需要显式地指出所需内存的尺寸。</li></ul></li><li>返回类型<ul><li>new操作符内存分配成功时，返回的是<strong>对象类型的指针</strong>，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。</li><li>malloc内存分配成功则是返回*<em>void *** ，需要通过强制类型转换将void</em>指针转换成我们需要的类型。</li></ul></li><li>分配失败<ul><li>new内存分配失败时，会抛出bac_alloc异常。</li><li>malloc分配内存失败时返回NULL。</li></ul></li><li>自定义类型<ul><li>new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。</li><li>malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</li></ul></li><li>重载<ul><li>C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。</li><li>而malloc不允许重载。</li></ul></li><li>内存区域<ul><li>new操作符从自由存储区（free store）上为对象动态分配内存空间，</li><li>而malloc函数从堆上动态分配内存。</li><li>自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。</li><li>而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。</li></ul></li></ul></blockquote><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><blockquote><p>虚函数的调用是通过<strong>虚函数表指针</strong>和<strong>虚函数表</strong>来实现的。</p><ul><li>虚函数表和类绑定，只此一份。虚函数表指针每个类对象都有，指针值都是同一个虚函数表的地址</li><li>虚函数指针vfptr不属于数据成员，vfptr的值是在<strong>构造函数内容</strong>执行之前进行初始化的，构造函数是根据本类的类型进行初始化的。所以，拷贝构造函数，或者赋值函数，都不会 影响到vfptr的值</li><li>对虚函数的调用，都是通过实体的vfptr所指的虚函数表来进行调用的 </li></ul></blockquote><h2 id="vector和list的区别"><a href="#vector和list的区别" class="headerlink" title="vector和list的区别"></a>vector和list的区别</h2><blockquote><p>vector和数组类似，拥有一段连续的内存空间，并且起始地址不变。<br>因此<strong>能高效的进行随机存取，时间复杂度为o(1)</strong>;<br>但因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。<br>另外，当数组中内存空间不够时，会重新申请一块内存空间并进行内存拷贝。</p></blockquote><blockquote><p>list是由双向链表实现的，因此内存空间是不连续的。<br>只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n);<br>但由于链表的特点，能高效地进行插入和删除。</p></blockquote><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><blockquote><ul><li><strong>单例模式：</strong>一般情况下，我们建立的类有些是属于工具性质的，所以不需要每次都去new一个对象，所以将默认的构造函数声明为私有，给外面提供一个实例接口就行了。（可用全局或静态变量代替，但会影响封装性）常和工厂模式结合使用，因为工厂只需要创建一个产品实例就可以了。</li></ul></blockquote><pre><code class="C++">class NetWork&#123;    NetWork* GetInstance() &#123;        if(net == NULL) &#123;             return new NetWork();        &#125;    &#125;    static NetWork* net;&#125;</code></pre><blockquote><ul><li><strong>观察者模式</strong>：当对象间有一对多的依赖关系时，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。</li></ul></blockquote><pre><code class="C++">class Subject//被观察者&#123;    Attach(Observer);//添加观察者             Detach(Observer);//移除观察者    Notify();//通知观察者                      list&lt;Observer*&gt; m_observers;//观察者链表&#125;class Observer//观察者&#123;    Update();&#125;</code></pre><blockquote><ul><li><strong>工厂模式</strong>：主要是将创建对象的具体过程给封装屏蔽起来，达到提高灵活性的目的。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>感知器</title>
      <link href="2021/03/16/%E6%84%9F%E7%9F%A5%E5%99%A8/"/>
      <url>2021/03/16/%E6%84%9F%E7%9F%A5%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="感知器"><a href="#感知器" class="headerlink" title="感知器"></a>感知器</h1><h2 id="感知器更新规则疑惑"><a href="#感知器更新规则疑惑" class="headerlink" title="感知器更新规则疑惑"></a>感知器更新规则疑惑</h2><p>$$<br>w_i\leftarrow w_i + \Delta w_i<br>$$</p><p>$$<br>\Delta w_i = \eta (lable - y)x_i<br>$$</p><p>$$<br>疑问：为何要乘上 x_i<br>$$</p><h3 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h3><p>$$<br>代码中把,loss=lable-y,作为损失值,而在更新权重w_i的时候，并没有以代码loss值作为依据对w_i求偏导，<br>$$</p><p>$$<br>实际上作者的损失值计算应该是,loss= \frac{1}{2}(lable-y)^2,,然后损失值loss对w_i求偏导，就得到了<br>$$</p><p>$$<br>\Delta w_i = \frac{\partial loss}{\partial w_i} = -(lable - y)x_i<br>$$</p><p>​            我们需要往<strong>函数的最小值的方向</strong>前进，而梯度是一个向量，它指向<strong>函数值上升最快</strong>的方向，只要向着梯度的反方向前进就可以达到目的，所以两个负号抵消，就变成了加上一个值。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode209.长度最小的子数组</title>
      <link href="2021/03/16/LeetCode209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>2021/03/16/LeetCode209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h1><blockquote><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的子数组，返回 0</p><pre><code>输入：s = 7, nums = [2,3,1,2,4,3]输出：2</code></pre><p>解释：子数组 [4,3]是该条件下的长度最小的子数组</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="双指针模拟滑动窗口"><a href="#双指针模拟滑动窗口" class="headerlink" title="双指针模拟滑动窗口"></a>双指针模拟滑动窗口</h3><blockquote><ul><li>主循环：滑动右边边界，计算窗口之和</li><li>判断条件：满足sum ≥ target<ul><li>操作：判断并修改窗口最小长度，移动左指针，修改sum值</li></ul></li><li>边界条件：<ul><li>右边界触及数组长度</li><li>最小长度 == 数组长度</li><li>最小长度始终等于初值，说明不存在，返回0</li></ul></li></ul></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="c++">class Solution &#123;public:    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;        int subLength = 0;      // 滑动窗口长度        int left=0, right;      // 左右双指针        int sum = 0;            // 滑动窗口之和        int len = nums.size();  // 数组长度        int res = len + 1;      // 结果        for(right = 0; right &lt; len; right++) &#123;            sum += nums[right];     // 计算窗口之和            while(sum &gt;= target) &#123;  // 满足条件                subLength = right - left + 1;   // 计算窗口长度                res = res &lt; subLength ? res : subLength;                    sum -= nums[left++];            &#125;        &#125;        return res == (len + 1) ? 0 : res;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/03/16/hello-world/"/>
      <url>2021/03/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
