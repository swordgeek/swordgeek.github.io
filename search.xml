<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试题</title>
      <link href="2021/03/31/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2021/03/31/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><blockquote><ul><li>OSI分层 （7层）<ul><li>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</li></ul></li><li>TCP/IP分层（4层）<ul><li>网络接口层、 网际层、运输层、 应用层。</li></ul></li><li>五层协议 （5层）<ul><li>物理层、数据链路层、网络层、运输层、 应用层。</li></ul></li><li>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器，网关）<ul><li>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）</li><li>网络层：<strong>IP</strong>、ICMP、<strong>ARP</strong>、<strong>RARP</strong>、OSPF、IPX、RIP、IGRP、 （路由器）</li><li>传输层：<strong>TCP</strong>、<strong>UDP</strong>、SPX</li><li>会话层：NFS、SQL、NETBIOS、RPC</li><li>表示层：JPEG、MPEG、ASII</li><li>应用层：<strong>FTP</strong>、<strong>DNS</strong>、Telnet、SMTP、<strong>HTTP</strong>、WWW、NFS</li></ul></li></ul></blockquote><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><blockquote><ol><li><p>端口</p><ul><li>HTTP的URL由“http://”起始且默认使用端口80</li><li>HTTPS的UR由“https://”起始且默认使用端口443。 </li></ul></li><li><p>安全性和资源消耗</p><ul><li>HTTP协议运行在TCP之上，所有传输的内容都是明文，<a href="">客户端</a>和服务器端都无法验证对方的身份。</li><li>HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。</li><li>所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。 </li></ul></li></ol><ul><li>对称加密<ul><li>密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密<a href="">算法</a>有DES、AES等；</li></ul></li><li>非对称加密<ul><li>密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密<a href="">算法</a>有RSA、DSA等。</li></ul></li></ul></blockquote><h3 id="HTTPS的加密过程"><a href="#HTTPS的加密过程" class="headerlink" title="HTTPS的加密过程"></a>HTTPS的加密过程</h3><blockquote><ul><li><p>证书验证，<a href="">客户端</a>发送一个证书请求个服务器端，服务器端返回证书，<a href="">客户端</a>对证书进行验证。 </p></li><li><p>交换密钥，使用非对称加密，<a href="">客户端</a>使用公钥进行加密，服务器端使用密钥解密。 </p></li><li><p>交换数据，使用对称加密的方式对数据进行加密，然后进行传输。</p></li></ul></blockquote><h3 id="长连接与短连接的区别"><a href="#长连接与短连接的区别" class="headerlink" title="长连接与短连接的区别"></a>长连接与短连接的区别</h3><blockquote><ul><li>长连接<ul><li>client方与server方先建立连接，连接建立后不断开，然后再进行报文发送和接收。这种方式下由于通讯连接一直存在。此种方式常用于P2P通信。</li></ul></li><li>短连接<ul><li>Client方与server每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此方式常用于一点对多点通讯。</li></ul></li></ul></blockquote><h3 id="HTTP2-0与HTTP1-x的区别"><a href="#HTTP2-0与HTTP1-x的区别" class="headerlink" title="HTTP2.0与HTTP1.x的区别"></a>HTTP2.0与HTTP1.x的区别</h3><blockquote><ul><li>新的二进制格式（Binary Format）<ul><li>HTTP1.x的解析是基于文本</li><li>HTTP2.0的协议解析决定采用二进制格式</li></ul></li><li>多路复用（MultiPlexing）：即连接共享，即每一个request都是是用作连接共享机制的</li><li>header压缩：HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li><li>服务端推送（server push）：同SPDY一样，HTTP2.0也具有server push功能。</li></ul></blockquote><h3 id="HTTP协议中的GET和POST方式的区别"><a href="#HTTP协议中的GET和POST方式的区别" class="headerlink" title="HTTP协议中的GET和POST方式的区别"></a>HTTP协议中的GET和POST方式的区别</h3><blockquote><ul><li><p>参数位置：GET方法参数位置包含在URL，POST方法参数包含在请求主体 </p></li><li><p>参数长度：GET方法的URL长度有限度，POST长度没有限制 </p></li><li><p>参数编码：GET方法参数编码是ASCII码，POST没有限制 </p></li><li><p>TCP数据包：GET方法产生一个TCP数据包，把首部和数据一起发送，POST方法产生两个TCP数据包，先发首部，服务器响应后再发数据</p></li></ul></blockquote><h3 id="Session和Cookie的区别"><a href="#Session和Cookie的区别" class="headerlink" title="Session和Cookie的区别"></a>Session和Cookie的区别</h3><blockquote><ul><li><p>储存位置：Cookie是<a href="">客户端</a>会话技术，数据保存在<a href="">客户端</a>，Session是服务器端会话技术，数据保存在服务器端。 </p></li><li><p>存储容量：Cookie一般&lt;=4KB，Session无限制。 </p></li><li><p>跨域支持：Cookie支持跨域，Session不支持。</p></li></ul></blockquote><h3 id="WebSocket通信流程"><a href="#WebSocket通信流程" class="headerlink" title="WebSocket通信流程"></a>WebSocket通信流程</h3><blockquote><ul><li><p>建立socket通信，包括客户端套接字（socket方法），服务器端绑定端口（bind方法），建立监听（listen方法），客户端创建连接（connect方法）。 </p></li><li><p>TCP三次握手建立连接 </p></li><li><p>客户端服务器端收发数据（send方法、recv方法），读写数据（read方法、write方法）。 </p></li><li><p>TCP四次挥手关闭连接 </p></li><li><p>关闭socket（close方法）</p></li></ul></blockquote><h3 id="DNS域名系统工作原理"><a href="#DNS域名系统工作原理" class="headerlink" title="DNS域名系统工作原理"></a>DNS域名系统工作原理</h3><blockquote><ol><li>查询 浏览器、操作系统 缓存。</li><li>请求 <strong>本地域名服务器</strong></li><li>本地域名服务器未命中缓存，其请求 <strong>根域名服务器</strong>。</li><li>根域名服务器返回所查询域的<strong>主域名服务器</strong>。（主域名、顶级域名，如com、cn）</li><li>本地域名服务器请求主域名服务器，获取该域名的 <strong>名称服务器</strong>（域名注册商的服务器）。</li><li>本地域名服务器向 名称服务器 请求 域名-IP 映射。</li><li>缓存解析结果</li></ol></blockquote><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><h3 id="TCP-UDP的区别"><a href="#TCP-UDP的区别" class="headerlink" title="TCP/UDP的区别"></a>TCP/UDP的区别</h3><blockquote><ul><li>连接<ul><li>UDP是无连接的，发送数据之前无需建立连接，发送数据结束后也无需释放连接。</li><li>TCP是面向连接的，在发送数据之前需要通过三次握手建立连接，发送数据结束后需要通过四次挥手释放连接。</li></ul></li><li>交付<ul><li>UDP用尽最大努力交付，即不保证可靠交付，主机不需要维持复杂的连接状态表。</li><li>TCP提供可靠交付，即通过TCP连接传送的数据，无差错、不丢失、不重复，并且按序到达。</li></ul></li><li>数据<ul><li>UDP是面向报文的，UDP对于应用层交下来的报文，添加首部后就向下交给IP层，既不合并，也不拆分，一次性交付一个完整的报文。</li><li>TCP是面向字节流的，TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</li></ul></li><li>通讯双方<ul><li>UDP支持一对一、一对多、多对一、多对多的交互通讯。</li><li>TCP连接是点对点（一对一），每一条TCP连接只能有两个端点。</li></ul></li><li>拥塞<ul><li>UDP没有拥塞控制，网络的拥塞不会使源主机的发送速率降低。</li><li>TCP通过慢启动、拥塞避免、快速重传、快速恢复等算法进行拥塞控制。</li></ul></li><li>首部<ul><li>UDP的首部开销小，只有8个字节。</li><li>TCP首部开销20字节。</li></ul></li></ul></blockquote><h3 id="TCP可靠连接的实现"><a href="#TCP可靠连接的实现" class="headerlink" title="TCP可靠连接的实现"></a>TCP可靠连接的实现</h3><blockquote><ul><li>TCP使用<strong>超时重传</strong>和<strong>冗余确认</strong>技术来处理超时、丢失等情况；<ul><li>发送方只设置一个定时器，只和发出去的最老的那个段相关联，一旦超时，发送方就只发送最老的那个报文段。</li><li><strong>快速重传：</strong>发送方收到某些段的连续3个冗余确认ACK，如果这时没有超时，就把这个段发出去。</li></ul></li><li>使用<strong>确认、序号</strong>等技术来保证按序到达；<ul><li><strong>累积确认：</strong>例如，发送方给接收方发送数据，接收方需要给ACK确认，如果ACK的number等于20，意味着接收方已经收到了19以及之前的所有的字节，并期望发送方从20（包括20）之后的字节开始发送。</li><li>如果接收方TCP的实体在接收窗口中接收到乱序到来的报文段，协议没有做出规范，可以缓存，也可以丢弃。</li></ul></li><li>使用<strong>校验和</strong>来检验是否报文段在传输过程中是否发生了错误；<ul><li>首先，把伪首部、TCP报头、TCP数据分为16位的字，如果总长度为奇数个字节，则在最后增添一个位都为0的字节。</li><li>把TCP报头中的校验和字段置为0（否则就陷入鸡生蛋还是蛋生鸡的问题）。</li><li>其次，用反码相加法累加所有的16位字（进位也要累加）。</li><li>最后，对计算结果取反，作为TCP的校验和。</li></ul></li></ul></blockquote><h3 id="TCP拥塞控制的方法"><a href="#TCP拥塞控制的方法" class="headerlink" title="TCP拥塞控制的方法"></a>TCP拥塞控制的方法</h3><blockquote><ul><li>慢启动<ul><li>当主机开始发送数据时，由于不清楚网络的负荷情况，如果立即把大量数据字节注入到网络，那么就有可能引起网络发生拥塞。所以应该先试探一下，由小到大逐渐增大拥塞窗口数值。<ul><li>连接建好的开始先初始化拥塞窗口$cwnd = 1$，表明可以传一个MSS大小的数据；</li><li>每当收到一个ACK，$cwnd++$; 呈线性上升；</li><li>每当过了一个往返时延RTT，$cwnd = cwnd \times 2$；呈指数上升</li><li>还有一个慢启动门限ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）</li></ul></li></ul></li><li>拥塞避免<ul><li>让拥塞窗口cwnd缓慢增大，即每经过一个往返时延RTT就把发送方的拥塞窗口cwnd加1.在拥塞避免阶段有“<strong>加法增大</strong>”的特点，拥塞窗口cwnd<strong>按线性规律缓慢增长</strong>。<ul><li>收到一个ACK时，cwnd = cwnd + 1/cwnd</li><li>当每过一个RTT时，cwnd = cwnd + 1</li></ul></li></ul></li><li>快速恢复<ul><li>对于引起TCP进入快速恢复状态的缺失报文段，对收到的每个冗余的ACK，cwnd的值增加一个MSS。最终，当对丢失报文段的一个ACK到达时，TCP在减半cwnd后进入拥塞避免状态。如果出现超时事件，将cwnd置为1，ssthresh设置为cwnd的一半，并进入慢启动状态。</li></ul></li></ul></blockquote><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="C:\Users\sword\AppData\Roaming\Typora\typora-user-images\image-20210331150233698.png" alt="image-20210331150233698"></p><blockquote><ul><li><p>第一次握手：<a href="">客户端</a>发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认； </p></li><li><p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态； </p></li><li><p>第三次握手：<a href="">客户端</a>收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，<a href="">客户端</a>和服务器进入ESTABLISHED状态，完成三次握手。 </p></li><li><p>握手过程中传送的包里不包含数据，三次握手完毕后，<a href="">客户端</a>与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p></li></ul></blockquote><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="https://qqadapt.qpic.cn/txdocpic/0/26079e0cc386c00fdb761115dffd4f85/0?w=975&h=629" alt="img"></p><blockquote><ul><li><p>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 </p></li><li><p>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。</p></li><li><p>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</p></li><li><p>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</p></li></ul></blockquote><h3 id="为什么要有TIME-WAIT-2ms"><a href="#为什么要有TIME-WAIT-2ms" class="headerlink" title="为什么要有TIME_WAIT 2ms"></a>为什么要有TIME_WAIT 2ms</h3><blockquote><ul><li>为了保证A发送的最后一个报文段能够达到B。</li><li>防止已失效的连接请求报文段出现在本连接。</li></ul></blockquote><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="交换机和路由器的区别"><a href="#交换机和路由器的区别" class="headerlink" title="交换机和路由器的区别"></a>交换机和路由器的区别</h3><blockquote><ul><li><p>工作层次：交换机主要工作在数据链路层，路由器主要工作在网络层</p></li><li><p>转发依据：交换机转发依据的对象是MAC地址，路由器转发依据的对象是IP地址</p></li><li><p>功能：交换机功能较简单，只是将主机连接起来组件局域网，路由器可以将局域网连接起来，还能分割广播域，还能提供防火墙</p></li></ul></blockquote><h3 id="ARP协议的作用"><a href="#ARP协议的作用" class="headerlink" title="ARP协议的作用"></a>ARP协议的作用</h3><blockquote><p>将IP地址转换为物理地址</p></blockquote><h3 id="ARP协议的工作原理"><a href="#ARP协议的工作原理" class="headerlink" title="ARP协议的工作原理"></a>ARP协议的工作原理</h3><blockquote><ul><li><p>首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。</p></li><li><p>当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机IP地址，源主机MAC地址，目的主机的IP地址。</p></li><li><p>当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。</p></li><li><p>源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败</p></li></ul></blockquote><h4 id="MAC表"><a href="#MAC表" class="headerlink" title="MAC表"></a>MAC表</h4><p><img src="https://qqadapt.qpic.cn/txdocpic/0/efbfcd2a8fb730fa08fae311330eed26/0?w=564&h=407" alt="img"></p><h4 id="ARP表"><a href="#ARP表" class="headerlink" title="ARP表"></a>ARP表</h4><p><img src="C:\Users\sword\AppData\Roaming\Typora\typora-user-images\image-20210331155359112.png" alt="image-20210331155359112"></p><h4 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h4><ul><li>IPv4</li></ul><p><img src="C:\Users\sword\AppData\Roaming\Typora\typora-user-images\image-20210331155526243.png" alt="image-20210331155526243"></p><ul><li>IPv6</li></ul><p><img src="C:\Users\sword\AppData\Roaming\Typora\typora-user-images\image-20210331155609955.png" alt="image-20210331155609955"></p><h3 id="IPV6地址的基本类型"><a href="#IPV6地址的基本类型" class="headerlink" title="IPV6地址的基本类型"></a>IPV6地址的基本类型</h3><blockquote><ul><li><p>单播（unicast）：单播就是传统的点对点通信。</p></li><li><p>多播（multicast）：多播是一点对多点的通信，数据报发送到一组计算机中的每一个。IPV6没有广播的术语，而是将广播看作多播的一个特例。</p></li><li><p>任播（anycast）：这是IPV6增加的一种类型。任播的终点是一组计算机，但是数据包只交付给其中一个，通常是距离最近的一个。</p></li></ul></blockquote><h3 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h3><blockquote><ul><li><p>内部网关协议RIP（Routing Information <a href="">Proto</a>col）：RIP是一种分布式的基于距离向量的路由选择协议。 </p></li><li><p>内部网关协议OPSF（Open Shortest Path First）：OSPF是使用分布式的链路状态协议。 </p></li><li><p>外部网关协议BGP（Border Gateway <a href="">Proto</a>col）：边界网关协议。</p></li></ul></blockquote><h3 id="epoll的工作方式"><a href="#epoll的工作方式" class="headerlink" title="epoll的工作方式"></a><strong>epoll的工作方式</strong></h3><blockquote><ul><li>水平触发（LT）<ul><li>若就绪的事件一次没有处理完要做的事件，就会一直去处理。即就会将没有处理完的事件继续放回到就绪队列之中（即那个内核中的链表），一直进行处理。 </li></ul></li><li>边缘触发（ET） <ul><li>就绪的事件只能处理一次，若没有处理完会在下次的其它事件就绪时再进行处理。而若以后再也没有就绪的事件，那么剩余的那部分数据也会随之而丢失。</li></ul></li></ul></blockquote><h2 id="浏览器输入网址之后发生了什么"><a href="#浏览器输入网址之后发生了什么" class="headerlink" title="浏览器输入网址之后发生了什么"></a>浏览器输入网址之后发生了什么</h2><blockquote><ol><li> DNS域名解析 </li><li> HTTP协议生成请求报文 </li><li> TCP协议将请求报文分割成报文段，进行可靠传输 </li><li> IP协议进行分组转发 </li><li> TCP协议重组请求报文 </li><li> HTTP协议对请求进行处理</li></ol><hr><ol><li><p>客户端浏览器通过DNS解析到<a href="http://www.baidu.com的ip地址220.181.27.48,通过这个ip地址找到客户端到服务器的路径.客户端浏览器发起一个http会话到220.161.27.48,然后通过tcp进行封装数据包,输入到网络层./">www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。</a></p></li><li><p>在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。</p></li><li><p>客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</p></li><li><p>客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。</p></li></ol></blockquote><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><blockquote><ul><li>进程是具有一定功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源调度和分配的一个独立单位。</li><li>线程是进程的实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。</li><li>一个进程可以有多个线程，多个线程也可以并发执行。</li><li>通俗点说，如果把浏览器看作是一个进程的话，那么浏览器下面的每个tab页可以看做是一个个的线程。</li></ul></blockquote><h3 id="线程同步的方式有哪些"><a href="#线程同步的方式有哪些" class="headerlink" title="线程同步的方式有哪些"></a>线程同步的方式有哪些</h3><blockquote><ul><li>互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。</li><li>信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li><li>事件（信号）：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li></ul></blockquote><h3 id="进程的通信方式有哪些"><a href="#进程的通信方式有哪些" class="headerlink" title="进程的通信方式有哪些"></a>进程的通信方式有哪些</h3><blockquote><ul><li>管道<ul><li>管道是一种半双工的通信方式，数据只能单项流动，并且只能在具有亲缘关系的进程间流动，进程的亲缘关系通常是父子进程。</li></ul></li><li>命名管道<ul><li>命名管道也是半双工的通信方式，它允许无亲缘关系的进程间进行通信。</li></ul></li><li>信号量<ul><li>信号量是一个计数器，用来控制多个进程对资源的访问，它通常作为一种锁机制。</li></ul></li><li>消息队列<ul><li>消息队列是消息的链表，存放在内核中并由消息队列标识符标识。</li></ul></li><li>信号<ul><li>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li></ul></li><li>共享内存<ul><li>共享内存就是映射一段能被其它进程访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问。</li></ul></li></ul></blockquote><h3 id="什么是缓冲区溢出？有什么危害？其原因是什么？"><a href="#什么是缓冲区溢出？有什么危害？其原因是什么？" class="headerlink" title="什么是缓冲区溢出？有什么危害？其原因是什么？"></a>什么是缓冲区溢出？有什么危害？其原因是什么？</h3><blockquote><ul><li><p>缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</p></li><li><p>危害有以下两点：</p></li><li><p>程序崩溃，导致拒绝额服务</p></li><li><p>跳转并且执行一段恶意代码</p></li><li><p>造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。</p></li></ul></blockquote><h3 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h3><blockquote><p>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。</p></blockquote><h3 id="死锁产生的四个条件（有一个条件不成立，则不会产生死锁）"><a href="#死锁产生的四个条件（有一个条件不成立，则不会产生死锁）" class="headerlink" title="死锁产生的四个条件（有一个条件不成立，则不会产生死锁）"></a>死锁产生的四个条件（有一个条件不成立，则不会产生死锁）</h3><blockquote><ul><li>互斥条件：一个资源一次只能被一个进程使用</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</li><li>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺</li><li>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li></ul></blockquote><h3 id="死锁的处理基本策略和常用方法"><a href="#死锁的处理基本策略和常用方法" class="headerlink" title="死锁的处理基本策略和常用方法"></a>死锁的处理基本策略和常用方法</h3><blockquote><ul><li><p>预防死锁</p><ul><li><strong>资源一次性分配：</strong>（破坏请求和保持条件）</li><li><strong>可剥夺资源：</strong>即当某进程新的资源未满足时，释放已占有的资源（破坏不可剥夺条件）</li><li><strong>资源有序分配法：</strong>系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li></ul></li><li><p>避免死锁</p><ul><li>银行家算法<ul><li>进程申请资源的数量是有限的，每个进程在第一次申请资源时要声明完成该项目所需的最大资源量，在满足所有资源要求时，进程应及时归还。系统在进程申请的资源数量不超过自己拥有的最大值时，都应尽量满足客户的需要。</li><li>可利用资源向量 Available</li><li>最大需求矩阵Max</li><li>分配矩阵 Allocation</li><li>需求矩阵Need</li><li>Need[i,j] = Max[i,j] - allocation[i, j]</li></ul></li></ul></li><li><p>检测死锁</p><ul><li>首先为每个进程和每个资源指定一个唯一的号码；</li><li>然后建立资源分配表和进程等待表。</li></ul></li><li><p>解除死锁</p><ul><li><p><strong>剥夺资源：</strong>从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；</p><p><strong>撤消进程：</strong>可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。</p></li></ul></li></ul></blockquote><h3 id="进程有哪几种状态"><a href="#进程有哪几种状态" class="headerlink" title="进程有哪几种状态"></a>进程有哪几种状态</h3><blockquote><ul><li>就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源</li><li>运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数</li><li>阻塞状态： 进程等待某种条件，在条件满足之前无法执行</li></ul></blockquote><h3 id="分页和分段的区别"><a href="#分页和分段的区别" class="headerlink" title="分页和分段的区别"></a>分页和分段的区别</h3><blockquote><ul><li>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。</li><li>段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定</li><li>段向用户提供二维地址空间；页向用户提供的是一维地址空间</li><li>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。</li></ul></blockquote><h3 id="操作系统中进程调度策略"><a href="#操作系统中进程调度策略" class="headerlink" title="操作系统中进程调度策略"></a>操作系统中进程调度策略</h3><blockquote><ul><li>FCFS(先来先服务)<ul><li>每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。</li></ul></li><li>优先级<ul><li>系统将从后备队列中选择若干个优先权最高的作业装入内存</li></ul></li><li>时间片轮转<ul><li>系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms 到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。</li></ul></li><li>多级反馈<ul><li>应设置多个就绪队列，并为各个队列赋予不同的优先级。</li><li>当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第<em>n</em>队列后，在第<em>n</em> 队列便采取按时间片轮转的方式运行。</li><li>仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程.</li></ul></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础</title>
      <link href="2021/03/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
      <url>2021/03/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机与网络发展的7个阶段"><a href="#计算机与网络发展的7个阶段" class="headerlink" title="计算机与网络发展的7个阶段"></a>计算机与网络发展的7个阶段</h1><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><blockquote><p>事先将数据装入卡带或者磁带，并且由计算机按照一定的吮吸进行读入。</p></blockquote><h2 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h2><blockquote><p>多个终端与同一个计算机连接，允许多个用户同时使用一台计算机的系统。</p></blockquote><ul><li>分时系统的重要特性包括多路性、独占性、交互性和及时性。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 38. 字符串的排列</title>
      <link href="2021/03/17/%E5%89%91%E6%8C%87Offer38.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
      <url>2021/03/17/%E5%89%91%E6%8C%87Offer38.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></h1><blockquote><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><pre><code>输入：s = &quot;abc&quot;输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</code></pre><p>解释：子数组 [4,3]是该条件下的长度最小的子数组</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="双指针模拟滑动窗口"><a href="#双指针模拟滑动窗口" class="headerlink" title="双指针模拟滑动窗口"></a>双指针模拟滑动窗口</h3><blockquote><ul><li>主循环：滑动右边边界，计算窗口之和</li><li>判断条件：满足sum ≥ target<ul><li>操作：判断并修改窗口最小长度，移动左指针，修改sum值</li></ul></li><li>边界条件：<ul><li>右边界触及数组长度</li><li>最小长度 == 数组长度</li><li>最小长度始终等于初值，说明不存在，返回0</li></ul></li></ul></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="c++">class Solution &#123;public:    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;        int subLength = 0;      // 滑动窗口长度        int left=0, right;      // 左右双指针        int sum = 0;            // 滑动窗口之和        int len = nums.size();  // 数组长度        int res = len + 1;      // 结果        for(right = 0; right &lt; len; right++) &#123;            sum += nums[right];     // 计算窗口之和            while(sum &gt;= target) &#123;  // 满足条件                subLength = right - left + 1;   // 计算窗口长度                res = res &lt; subLength ? res : subLength;                    sum -= nums[left++];            &#125;        &#125;        return res == (len + 1) ? 0 : res;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指 Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>感知器</title>
      <link href="2021/03/16/%E6%84%9F%E7%9F%A5%E5%99%A8/"/>
      <url>2021/03/16/%E6%84%9F%E7%9F%A5%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="感知器"><a href="#感知器" class="headerlink" title="感知器"></a>感知器</h1><h2 id="感知器更新规则疑惑"><a href="#感知器更新规则疑惑" class="headerlink" title="感知器更新规则疑惑"></a>感知器更新规则疑惑</h2><p>$$<br>w_i\leftarrow w_i + \Delta w_i<br>$$</p><p>$$<br>\Delta w_i = \eta (lable - y)x_i<br>$$</p><p>$$<br>疑问：为何要乘上 x_i<br>$$</p><h3 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h3><p>$$<br>代码中把,loss=lable-y,作为损失值,而在更新权重w_i的时候，并没有以代码loss值作为依据对w_i求偏导，<br>$$</p><p>$$<br>实际上作者的损失值计算应该是,loss= \frac{1}{2}(lable-y)^2,,然后损失值loss对w_i求偏导，就得到了<br>$$</p><p>$$<br>\Delta w_i = \frac{\partial loss}{\partial w_i} = -(lable - y)x_i<br>$$</p><p>​            我们需要往<strong>函数的最小值的方向</strong>前进，而梯度是一个向量，它指向<strong>函数值上升最快</strong>的方向，只要向着梯度的反方向前进就可以达到目的，所以两个负号抵消，就变成了加上一个值。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode209.长度最小的子数组</title>
      <link href="2021/03/16/LeetCode209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>2021/03/16/LeetCode209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h1><blockquote><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的子数组，返回 0</p><pre><code>输入：s = 7, nums = [2,3,1,2,4,3]输出：2</code></pre><p>解释：子数组 [4,3]是该条件下的长度最小的子数组</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="双指针模拟滑动窗口"><a href="#双指针模拟滑动窗口" class="headerlink" title="双指针模拟滑动窗口"></a>双指针模拟滑动窗口</h3><blockquote><ul><li>主循环：滑动右边边界，计算窗口之和</li><li>判断条件：满足sum ≥ target<ul><li>操作：判断并修改窗口最小长度，移动左指针，修改sum值</li></ul></li><li>边界条件：<ul><li>右边界触及数组长度</li><li>最小长度 == 数组长度</li><li>最小长度始终等于初值，说明不存在，返回0</li></ul></li></ul></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="c++">class Solution &#123;public:    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;        int subLength = 0;      // 滑动窗口长度        int left=0, right;      // 左右双指针        int sum = 0;            // 滑动窗口之和        int len = nums.size();  // 数组长度        int res = len + 1;      // 结果        for(right = 0; right &lt; len; right++) &#123;            sum += nums[right];     // 计算窗口之和            while(sum &gt;= target) &#123;  // 满足条件                subLength = right - left + 1;   // 计算窗口长度                res = res &lt; subLength ? res : subLength;                    sum -= nums[left++];            &#125;        &#125;        return res == (len + 1) ? 0 : res;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/03/16/hello-world/"/>
      <url>2021/03/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
